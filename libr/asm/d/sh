add=add binary
addc=add with carry
addv=add with (v flag) overflow check
and=bitwise and
and.b=bitise and (byte)
bf/s=branch if false with delay slot
bf=branch if false
bra=branch
braf=branch far
bsr=branch to subroutine
bsrf=branch to subroutine far
bt/s=branch if true with delay slot
bt=branch if true
clrmac=clear mac register
clrs=clear s bit
clrt=clear t bit
cmp/eq=Compare Rm,Rn : set T if Rn == Rm
cmp/ge=Compare Rm,Rn : set T if Rn >= Rm (signed)
cmp/gt=Compare Rm,Rn : set T if Rn > Rm (signed)
cmp/hi=Compare Rm,Rn : set T if  Rn > Rm (unsigned)
cmp/hs=Compare Rm,Rn : set T if  Rn >= Rm (unsigned)
cmp/pl=set T if Rn > 0
cmp/pz=set T if Rn >= 0
cmp/str=Compare Rm,Rn : set T if any bytes are equal
div0s=divide (step 0) as signed
div0u=divide (step 0) as unsigned
div1=divide 1 step
dmuls.l=double-length multiply as signed
dmulu.l=double-length multiply as unsigned
dt=decrement and test
exts.b=extend byte as signed
exts.w=extend word as signed
extu.b=extend byte as unsigned
extu.w=extend word as unsigned
fabs=floating-point absolute value
fadd=floating-point add
fcmp/eq=Compare (float) FRm, FRn: set T if FRm == FRn
fcmp/gt=Compare (float) FRm, FRn: set T if FRn > FRm
fcnvds=floating-point convert double to single precision
fcnvsd=floating-point convert single to double precision
fdiv=floating-point divide
fipr=floating-point inner product
fldi0=floating-point load immediate 0.0
fldi1=floating-point loa immediate 1.0
flds=floating-point load to system register
float=floating-point convert from integer
fmac=floating-point multiply and accumulate
fmov=floating-point move
fmov.s=floating-point move
fmul=floating-point multiply
fneg=floating-point negate value
frchg=fr-bit change
fschg=sz-bit change
fsqrt=floating-point square root
fsts=floating-point store system register
fsub=floating-point subtract
ftrc=floating-point truncate and convert to integer
ftrv=floating-point transform vector
jmp=jump
jsr=jump to subroutine
ldc=load to control register
ldc.l=load to control register
lds=load to fpu/system register
lds.l=load to fpu/system register
ldtlb=load pteh/ptel/ptea to tlb
mac.l=multiply and accumulate long
mac.w=multiply and accumulate word
mov=move data
mov.b=move byte
mov.w=move word
mov.l=move longword
mova=move effective address
movca.l=move with cache block allocation
movt=move t bit to Rn
mul.l=multiply long
muls.w=multiply as signed word
mulu.w=multiply as unsigned word
neg=negate
negc=negate with carry
nop=no operation
not=not-logical complement
ocbi=operand cache block invalidate
ocbp=operand cache block purge
ocbwb=operand cache block write back
or=bitwise or
or=bitwise or (byte)
pref=prefetch data to cache
rotcl=rotate with carry left
rotcr=rotate with carry right
rotl=rotate left
rotr=rotate right
rte=return from exception
rts=return from subroutine
sets=set s bit
sett=set t bit
shad=shift arithmetic dynamically
shal=shift arithmetic left
shar=shift arithmetic right
shld=shift logical dynamically
shll=shift logical left
shlln=n bits shift logical left
shlr=shift logical right
shlrn=n bits shift logical right
sleep=sleep
stc=store control register
stc.l=store control register
sts=store system/fpu register
sts.l=store system/fpu register
sub=subtract binary
subc=subtract with carry
subv=subtract with (v flag) underflow check
swap.b=swap register lower bytes
swap.w=swap register words
tas.b=test and set byte
trapa=trap always
tst=test logical
tst.b=test logical, byte
xor=bitwise exclusive-or
xor.b=bitwise exclusive-or (byte)
xtrct=Middle extraction from linked registers
