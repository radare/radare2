data structs:
callstack for fat mach:

 ► f 0     7ffff776fbac r_bin_fatmach0_init+13
   f 1     7ffff777048e r_bin_fatmach0_from_bytes_new+159
   f 2     7ffff776f877 oneshot+121 
   f 3     7ffff776fab7 oneshotall+58  <--- returns a list of extracted bins
   f 4     7ffff76aa851 r_bin_file_xtr_load_bytes+262 <-- calls extractor function at the given offsets	
													<--- returns RBinFile object with xtr_data = list of bins from oneshotall
													// This function populate RBinFile->xtr_data, that information is enough to
													// create RBinObject when needed using r_bin_file_object_new_from_xtr_dat
													
   f 5     7ffff769c3a7 r_bin_load_io_at_offset_as_sz+1140 <-- determines sz to be used (??)
															<-- modifies and returns bin object with bin->file and bin->cur set to 
																RbinFile returned from previous steps
   f 6     7ffff769c4a4 r_bin_load_io_at_offset_as+81 <-- checks bytes to determine which extractor to be used
   f 7     7ffff769bf2a r_bin_load_io+68  <-- init RIOBind
   f 8     7ffff769b9e0 r_bin_load+369  <-- configure RBinOptions ie. address to start reading from
   f 9     7ffff76ac9a9 r_bin_open+158
   f 10     5555555593a0 main+6770

Extractor plugins are defined statically in this config file before rabin is ran:
vim libr/config.h

typedef struct r_bin_xtr_extract_t {
	char *file;
	ut8 *buffer;
	ut64 size;
	ut64 offset;
	ut64 baddr;
	ut64 laddr;
	int file_count;
	int loaded;
	RBinXtrMetadata *metadata;
} RBinXtrData;

typedef struct r_bin_xtr_metadata_t {
	char *arch;
	int bits;
	char *libname;
	char *machine;
	char *type;
} RBinXtrMetadata;

//base binary format in radare
//contains 
typedef struct r_bin_t {
	const char *file;
	RBinFile *cur;
	int narch;
	void *user;
	/* preconfigured values */
	int debase64;
	int minstrlen;
	int maxstrlen;
	ut64 maxstrbuf;
	int rawstr;
	Sdb *sdb;
	RIDStorage *ids;
	RList/*<RBinPlugin>*/ *plugins;
	RList/*<RBinXtrPlugin>*/ *binxtrs;
	RList/*<RBinLdrPlugin>*/ *binldrs;
	RList/*<RBinFile>*/ *binfiles;
	PrintfCallback cb_printf;
	int loadany;
	RIOBind iob;
	char *force;
	int is_debugger;
	bool want_dbginfo;
	int filter; // symbol filtering
	char strfilter; // string filtering
	char *strpurge; // purge false positive strings
	char *srcdir; // dir.source
	char *prefix; // bin.prefix
	ut64 filter_rules;
	bool demanglercmd;
	bool verbose;
	bool io_owned;
	bool use_xtr; // use extract plugins when loading a file?
	bool use_ldr; // use loader plugins when loading a file?
} RBin;

//options representing the opened bin file
typedef struct r_bin_options_t {
	ut64 offset; // starting physical address to read from the target file
	ut64 baseaddr; // where the linker maps the binary in memory
	ut64 loadaddr; // the desired offset where the binary should be loaded
	ut64 size; // restrict the size of the target fd
	int xtr_idx; // load Nth binary
	int rawstr;
	int iofd;
	char *name; // or comment :?
} RBinOptions;


// XXX: this is a copy of RBinObject
typedef struct r_bin_file_t {
	char *file;
	int fd;
	int size;
	int rawstr;
	int strmode;
	ut32 id; 
	RBuffer *buf;
	ut64 offset;
	RBinObject *o;
	void *xtr_obj;
	ut64 loadaddr;
	/* values used when searching the strings */
	int minstrlen;
	int maxstrlen;
	int narch;
	struct r_bin_xtr_plugin_t *curxtr;
	struct r_bin_plugin_t *curplugin;
	RList *objs;
	RList *xtr_data; //list of RBinXtrData
	Sdb *sdb;
	Sdb *sdb_info;
	Sdb *sdb_addrinfo;
	struct r_bin_t *rbin;
} RBinFile;


//RIOBind defines a driver interface for the file
//keep in mind that r2 supports not just files, but also more exotic binary formats such as network sockets
//and filesystems. RIOBind defines a common set of functions for each of these devices, leaving implementation undefined
//analogous to struct dev in linux drivers
typedef struct r_io_bind_t {
	int init;
	RIO *io;
	RIODescUse desc_use;
	RIODescGet desc_get;
	RIODescSize desc_size;
	RIOOpen open;
	RIOOpenAt open_at;
	RIOClose close;
	RIOReadAt read_at;
	RIOAlReadAt al_read_at;	//needed for esil
	RIOWriteAt write_at;
	RIOSystem system;
	RIOFdOpen fd_open;
	RIOFdClose fd_close;
	RIOFdSeek fd_seek;	//needed for esil
	RIOFdSize fd_size;
	RIOFdRead fd_read;	//needed for esil
	RIOFdWrite fd_write;	//needed for esil
	RIOFdReadAt fd_read_at;
	RIOFdWriteAt fd_write_at;
	RIOFdIsDbg fd_is_dbg;
	RIOFdGetName fd_get_name;
	RIOFdGetMap fd_get_map;
	RIOFdRemap fd_remap;
	RIOAlSort al_sort;	//needed for esil
	RIOAlFree al_free;	//needed for esil
	RIOAlGetFbufByflags al_buf_byflags;	//needed for esil
	RIOIsValidOff is_valid_offset;
	RIOAddrIsMapped addr_is_mapped;
	RIOSectionVgetSecsAt sections_vget;
	RIOSectionVgetSec sect_vget;
	RIOSectionAdd section_add;
} RIOBind;

Initializing PE files
Figure out execution trace for dotnet files	

rabin2 -A helloworld.dll
 ► f 0     7ffff774863b bin_pe_init_hdr+12
   f 1     7ffff774ecc1 bin_pe_init+145
   f 2     7ffff7752be8 Pe32_r_bin_pe_new_buf+197
   f 3     7ffff7741dcb load_buffer+73
   f 4     7ffff76ab2f8 r_bin_object_new+432
   f 5     7ffff76a9bbe r_bin_file_new_from_bytes+504
   f 6     7ffff769c427 r_bin_load_io_at_offset_as_sz+1268
   f 7     7ffff769c4a4 r_bin_load_io_at_offset_as+81
   f 8     7ffff769bf2a r_bin_load_io+68
   f 9     7ffff769b9e0 r_bin_load+369
   f 10     7ffff76ac9a9 r_bin_open+158
Breakpoint bin_pe_init_hdr
